# Day 3

```elixir
Mix.install([
  {:kino, "~> 0.11.3"}
])
```

## Section

```elixir
input = Kino.Input.textarea("Input")
```

```elixir
input_data = Kino.Input.read(input)
# m = %{}
rows = String.split(input_data, "\n")
rrows = Enum.zip(1..length(rows), rows)

defmodule Sol do
  def read_col({row_id, row}, m) do
    cols = Enum.zip(1..String.length(row), String.to_charlist(row))
    Enum.reduce(cols, m, fn {col_id, letter}, m -> Map.put(m, {row_id, col_id}, letter) end)
  end

  def read(text) do
    rows = String.split(text)
    row_n = length(rows)
    col_n = String.length(hd(rows))

    map =
      Enum.zip(1..length(rows), rows)
      |> Enum.reduce(%{}, fn row_data, acc -> Sol.read_col(row_data, acc) end)

    {row_n, col_n, map}
  end

  def symbol_near?(r, c, matrix) do
    has_star =
      Enum.any?(
        [
          {r - 1, c - 1},
          {r - 1, c},
          {r - 1, c + 1},
          {r, c - 1},
          {r, c + 1},
          {r + 1, c - 1},
          {r + 1, c},
          {r + 1, c + 1}
        ],
        fn pos ->
          matrix[pos] != ?. and (matrix[pos] < ?0 or matrix[pos] > ?9) and matrix[pos] != nil
        end
      )

    # has_star = matrix[{r-1,c-1}]!=?. or \
    # matrix[{r-1,c}]!=?. or \
    # matrix[{r-1,c+1}]!=?. or \
    # matrix[{r,c-1}]!=?. or \
    # matrix[{r,c+1}]!=?. or \
    # matrix[{r+1,c-1}]!=?. or \
    # matrix[{r+1,c}]!=?. or \
    # matrix[{r+1,c+1}]!=?.
    IO.inspect({r, c, has_star})
    has_star
    # Enum.each(Enum.with_index(matrix), fn {row, row_index} ->
    #  Enum.each(Enum.with_index(row), fn {col, col_index} ->
    #    IO.puts("Row #{row_index}, Col #{col_index}: #{col}")
    #  end) end)
  end

  def get_row_score(row_id, col_id, col_n, map, score, current_val, current_valid)
      when col_id > col_n do
    # IO.inspect({"RIGHT", col_id, current_val, current_valid})
    # if current_valid, do: score, else: 0
    score
  end

  def get_row_score(row_id, col_id, col_n, map, score, current_val, current_valid) do
    letter = Map.get(map, {row_id, col_id}, ?.)

    IO.inspect(["letter", letter, current_valid, current_val, "score", score])

    case letter do
      _ when letter >= ?0 and letter <= ?9 ->
        Sol.get_row_score(
          row_id,
          col_id + 1,
          col_n,
          map,
          score,
          current_val * 10 + letter - ?0,
          current_valid or Sol.symbol_near?(row_id, col_id, map)
        )

      _ when current_valid ->
        Sol.get_row_score(row_id, col_id + 1, col_n, map, score + current_val, 0, false)

      _ ->
        Sol.get_row_score(row_id, col_id + 1, col_n, map, score, 0, false)
    end
  end

  def solve(row_n, col_n, map) do
    for row <- 1..row_n do
      Sol.get_row_score(row, 1, col_n, map, 0, 0, false)
    end
    |> Enum.sum()
  end
end

# Sol.read_col({1, "123.."}, %{})
{row_n, col_n, map} = Sol.read(input_data)
Sol.solve(row_n, col_n, map)
```

```elixir
matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]

Enum.each(1..3, fn row_index ->
  Enum.each(1..3, fn col_index ->
    IO.puts("Row #{row_index}, Col #{col_index}: #{matrix[row_index][col_index]}")
  end)
end)
```
